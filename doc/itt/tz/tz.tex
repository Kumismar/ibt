\documentclass[a4paper]{article}

\usepackage[left=2cm, top=3cm, text={17cm, 24cm}]{geometry}
\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{fancyvrb}

\author{Ondřej Koumar \\ \href{mailto:xkouma02@stud.fit.vutbr.cz}{xkouma02@stud.fit.vutbr.cz}}
\title{\huge Syntaktická analýza založená na několika gramatikách}
\date{\today}

\begin{document}

\maketitle

\section*{Motivace}
Syntaktická analýza a~obecně překladače často zůstávají v~praxi poněkud vzdálené od teoretických konceptů.
I~přes bohatou teorii formálních jazyků, konkrétně například gramatik a~gramatických systémů, se v~praxi často při syntaktické analýze upřednostňují jednoduché postupy.

Má bakalářská práce se snaží spojit teoretický svět s~praktickým využitím. 
Pro syntaktickou analýzu využívám gramatický systém s~několika gramatikami, ale implementace zůstává jednoduchá a~srozumitelná pomocí dvou zásobníkových automatů, LL tabulky a~precedenční analýzy výrazů.
Výsledkem této analýzy bude abstraktní syntaktický strom.

\section*{Implementovaný jazyk}
Nejdříve se podíváme na jazyk, který je navrhnutými gramatikami popsán.
Zatím nemá jméno, nazvěme jej pracovně KOUBP.
Je založen na jazyce IFJ22, který je založen na jazyce PHP.
Jazyk KOUBP je staticky typovaný jazyk, tedy datový typ všech proměnných a~konstant je znám už za překladu.

\subsection*{Konstrukce jazyka}
Jazyk KOUBP má čtyři základní datové typy, a~to \texttt{int}, \texttt{float}, \texttt{bool}, \texttt{string}.
Obsahuje konstrukce, které bys\-te očekávali u~každého imperativního programovacího jazyka\,--\,\texttt{while} a~\texttt{for} cykly, příkazy \texttt{if-elseif-else} a~\texttt{return}, jednoduché aritmetické výrazy a~operátory typu sčítání a~odčítání, relační operátory, ale například i~konkatenaci řetězců či logické operátory \mbox{\texttt{\&\&} a~\texttt{||}}.
Kód může být libovolně rozčleněn do funkcí, které mohou a~nemusí mít návratový typ.

\subsection*{Oddělovač příkazů}
Všechny příkazy musí být ukončeny středníkem, který se používá jako od\-dě\-lo\-vač příkazů.
Výjimkou jsou bloky kódu uzavřené ve složených závorkách. Za takovým blokem středník následovat nemusí, ale uvnitř bloku kódu je žádoucí každý příkaz oddělit.

Blok kódu může být použit samostatně, nicméně typicky jej vidíme za konstrukcemi \texttt{while}, \texttt{for}, \texttt{if}, případně při definici funkce.
Příklad bloku kódu lze vidět na obrázku \ref{fig:blok_kodu}.
\begin{figure}[ht]
	\centering
    \hspace{-1cm}
	\begin{BVerbatim}
    prikaz;
    { 
        prikaz;
        prikaz;
    }
    prikaz;
	\end{BVerbatim}
	\caption{Příklad použití bloku kódu}
	\label{fig:blok_kodu}
\end{figure}

Středník lze použít nejen jako oddělovač příkazů, může být také chápán jako samostatný příkaz.
Jeho význam se dá přirovnat k instrukci \texttt{NOP} ve strojovém jazyce/asembleru.

\section*{Gramatický systém}

Gramatický systém, který popisuje jazyk KOUBP, je postaven na \emph{CD (cooperating distributed)} gramatických systémech.
Tento systém se skládá ze šesti komponent, z nichž každá reprezentuje část navrhovaného jazyka tak, aby pravidla byla systematicky rozdělena.
Motivace k tomuto přístupu je podobná členění zdrojových kódů do logických celků.
Zároveň je ale důležité, aby se moc nezvýšila náročnost implementace a vyplatilo se rozdělení do více gramatik udělat.

Následují gramatiky/komponenty, které dohromady tvoří gramatický systém jazyka KOUBP.
V nadpise vizte ucelenou část jazyka, kterou daná pravidla tvoří.

\subsection*{Struktura programu}
\texttt{<program> -> <statement>\textsubscript{2} <statementList>\textsubscript{1}} \\
\texttt{<program> -> <functionDef>\textsubscript{2} <statementList>\textsubscript{1}} \\[1em]
\texttt{<statementList> -> <statement>\textsubscript{2} <statementList>\textsubscript{1}} \\
\texttt{<statementList> -> <functionDef>\textsubscript{3} <statementList>\textsubscript{1}} \\
\texttt{<statementList> -> }$\varepsilon$ 

\subsection*{Příkazy a běžné konstrukce}
\texttt{<statement> -> if ( <expression>\textsubscript{4} ) <codeBlock>\textsubscript{5} <if2>\textsubscript{2}} \\
\texttt{<statement> -> while ( <expression>\textsubscript{4} ) <codeBlock>\textsubscript{5}} \\
\texttt{<statement> -> for ( <expression>\textsubscript{4} ; <expression>\textsubscript{4} ; <expression>\textsubscript{4} ) <codeBlock>\textsubscript{5}} \\
\texttt{<statement> -> <expression>\textsubscript{4} ;} \\
\texttt{<statement> -> return <returnExp>\textsubscript{2} ;}\\
\texttt{<statement> -> <codeBlock>\textsubscript{5}}\\
\texttt{<statement> -> ;}\\[1em]
\texttt{<if2> -> elseif ( <expression>\textsubscript{4} ) <codeBlock>\textsubscript{5} <if2>\textsubscript{2}}\\
\texttt{<if2> -> else <codeBlock>\textsubscript{5}}\\
\texttt{<if2> -> }$\varepsilon$\\[1em]
\texttt{<returnExp> -> <expression>\textsubscript{4}}\\
\texttt{<returnExp> -> $\varepsilon$}

\subsection*{Definice funkce}
\texttt{<functionDef> -> function funcName ( <params>\textsubscript{3} ) : <funcType>\textsubscript{3} <codeBlock>\textsubscript{5}} \\[1em]
\texttt{<params> -> <type>\textsubscript{6} variable <params2>\textsubscript{3}} \\[1em]
\texttt{<params2> -> , <type>\textsubscript{6} variable <params2>\textsubscript{3}}\\
\texttt{<params2> -> $\varepsilon$}\\[1em]
\texttt{<funcType> -> <type>\textsubscript{6}}\\
\texttt{<funcType> -> $\varepsilon$}

\subsection*{Výrazy}
\texttt{<expression> -> <expression>\textsubscript{4} $\lfloor$+ - * / . \&\& || == != > < >= <=$\rceil$ <expression>\textsubscript{4}}\\
\texttt{<expression> -> $\lfloor$! -$\rceil$ <expression>\textsubscript{4}}\\
\texttt{<expression> -> variable}\\
\texttt{<expression> -> constant}\\
\texttt{<expression> -> funcName ( <args>\textsubscript{4} )}\\
\texttt{<expression> -> ( <expression>\textsubscript{4} )}\\[1em]
\texttt{<args> -> <expression>\textsubscript{4} <args2>\textsubscript{4}}\\
\texttt{<args> -> $\varepsilon$}\\[1em]
\texttt{<args2> -> , <expression>\textsubscript{4} <args2>\textsubscript{4}}\\
\texttt{<args2> -> $\varepsilon$}

\subsection*{Blok kódu}
Všimněme si, že neterminály \emph{codeBlock\textsubscript{5}} a \emph{statement\textsubscript{2}} se mohou navzájem derivovat donekonečna a~po\-ten\-ci\-ál\-ně by mohl nastat \emph{deadlock}.
Po teoretické stránce se s tímto faktem počítá a gramatiky se nebudou nijak přiz\-pů\-so\-bo\-vat, tato problematika bude vyřešena implementačně, zásobníkový automat se s pomocí LL ta\-bul\-ky bude chovat deterministicky. \\[1em]
\texttt{<codeBlock> -> \{ <statements>\textsubscript{5} \}}\\
\texttt{<codeBlock> -> <statement>\textsubscript{2}}\\[1em]
\texttt{<statements> -> <statement>\textsubscript{2} <statements>\textsubscript{5}}\\
\texttt{<statements> -> $\varepsilon$}

\subsection*{Datové typy}
\texttt{<type> -> int}\\
\texttt{<type> -> float}\\
\texttt{<type> -> string}\\
\texttt{<type> -> bool}

\section*{Implementace}
Implementujeme syntaktický analyzátor v jazyce C++ s dvěma zásobníkovými automaty\,--\,jeden pro analýzu s~LL tabulkou a druhý pro precedenční analýzu výrazů.
Precedenční analýza výrazů bude prováděna obvyklým způsobem, tedy redukcí terminálů a případně pravidel na zásobníku.

Analýza s LL tabulkou bude upravena na používání uspořádaných dvojic \emph{(číslo gramatiky, číslo pravidla)} namísto pravidel v položkách tabulky.
Číslo gramatiky bude předáno tovární metodě, která vytvoří instanci jedné z gramatik dědících od abstraktní třídy \texttt{Grammar}.
Tato třída obsahuje polymorfní metodu \texttt{Expand(unsigned ruleNumber)}, která vrací reverzovaný seznam terminálů a neterminálů reprezentující pravou stranu daného pravidla.
Reverzované pravidlo se vloží na zásobník a analýza bude pokračovat dalším cyklem.

V každém kroku syntaktické analýzy bude generován uzel abstraktního syntaktického stromu.

\subsubsection*{Možná rozšíření}
Syntaktický analyzátor a jeho datové struktury jsou koncipovány s ohledem na jednoduchou rozšiřitelnost projektu.
Aktuálně pracujeme s pevně danou posloupností terminálů/tokenů, kterou analyzátor přijímá jako seznam.
Nicméně, máme v plánu budoucí rozšíření projektu o lexikální analyzátor, což umožní psát skutečné programy v jazyce KOUBP.

Týká se to i jednoduchých sémantických kontrol, které jsou v každém kvalitním syntaktickém analyzátoru žádoucí.

\end{document}